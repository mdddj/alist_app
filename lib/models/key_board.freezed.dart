// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'key_board.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TvKey {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TvKeyCopyWith<$Res> {
  factory $TvKeyCopyWith(TvKey value, $Res Function(TvKey) then) =
      _$TvKeyCopyWithImpl<$Res, TvKey>;
}

/// @nodoc
class _$TvKeyCopyWithImpl<$Res, $Val extends TvKey>
    implements $TvKeyCopyWith<$Res> {
  _$TvKeyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TvKeyUpImplCopyWith<$Res> {
  factory _$$TvKeyUpImplCopyWith(
          _$TvKeyUpImpl value, $Res Function(_$TvKeyUpImpl) then) =
      __$$TvKeyUpImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyUpImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyUpImpl>
    implements _$$TvKeyUpImplCopyWith<$Res> {
  __$$TvKeyUpImplCopyWithImpl(
      _$TvKeyUpImpl _value, $Res Function(_$TvKeyUpImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyUpImpl extends TvKeyUp {
  const _$TvKeyUpImpl() : super._();

  @override
  String toString() {
    return 'TvKey.up()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyUpImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return up();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return up?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (up != null) {
      return up();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return up(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return up?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (up != null) {
      return up(this);
    }
    return orElse();
  }
}

abstract class TvKeyUp extends TvKey {
  const factory TvKeyUp() = _$TvKeyUpImpl;
  const TvKeyUp._() : super._();
}

/// @nodoc
abstract class _$$TvKeyDownImplCopyWith<$Res> {
  factory _$$TvKeyDownImplCopyWith(
          _$TvKeyDownImpl value, $Res Function(_$TvKeyDownImpl) then) =
      __$$TvKeyDownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyDownImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyDownImpl>
    implements _$$TvKeyDownImplCopyWith<$Res> {
  __$$TvKeyDownImplCopyWithImpl(
      _$TvKeyDownImpl _value, $Res Function(_$TvKeyDownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyDownImpl extends TvKeyDown {
  const _$TvKeyDownImpl() : super._();

  @override
  String toString() {
    return 'TvKey.down()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyDownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return down();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return down?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (down != null) {
      return down();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return down(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return down?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (down != null) {
      return down(this);
    }
    return orElse();
  }
}

abstract class TvKeyDown extends TvKey {
  const factory TvKeyDown() = _$TvKeyDownImpl;
  const TvKeyDown._() : super._();
}

/// @nodoc
abstract class _$$TvKeyLeftImplCopyWith<$Res> {
  factory _$$TvKeyLeftImplCopyWith(
          _$TvKeyLeftImpl value, $Res Function(_$TvKeyLeftImpl) then) =
      __$$TvKeyLeftImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyLeftImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyLeftImpl>
    implements _$$TvKeyLeftImplCopyWith<$Res> {
  __$$TvKeyLeftImplCopyWithImpl(
      _$TvKeyLeftImpl _value, $Res Function(_$TvKeyLeftImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyLeftImpl extends TvKeyLeft {
  const _$TvKeyLeftImpl() : super._();

  @override
  String toString() {
    return 'TvKey.left()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyLeftImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return left();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return left?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return left(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return left?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (left != null) {
      return left(this);
    }
    return orElse();
  }
}

abstract class TvKeyLeft extends TvKey {
  const factory TvKeyLeft() = _$TvKeyLeftImpl;
  const TvKeyLeft._() : super._();
}

/// @nodoc
abstract class _$$TvKeyRightImplCopyWith<$Res> {
  factory _$$TvKeyRightImplCopyWith(
          _$TvKeyRightImpl value, $Res Function(_$TvKeyRightImpl) then) =
      __$$TvKeyRightImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyRightImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyRightImpl>
    implements _$$TvKeyRightImplCopyWith<$Res> {
  __$$TvKeyRightImplCopyWithImpl(
      _$TvKeyRightImpl _value, $Res Function(_$TvKeyRightImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyRightImpl extends TvKeyRight {
  const _$TvKeyRightImpl() : super._();

  @override
  String toString() {
    return 'TvKey.right()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyRightImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return right();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return right?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return right(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return right?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (right != null) {
      return right(this);
    }
    return orElse();
  }
}

abstract class TvKeyRight extends TvKey {
  const factory TvKeyRight() = _$TvKeyRightImpl;
  const TvKeyRight._() : super._();
}

/// @nodoc
abstract class _$$TvKeyOkImplCopyWith<$Res> {
  factory _$$TvKeyOkImplCopyWith(
          _$TvKeyOkImpl value, $Res Function(_$TvKeyOkImpl) then) =
      __$$TvKeyOkImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyOkImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyOkImpl>
    implements _$$TvKeyOkImplCopyWith<$Res> {
  __$$TvKeyOkImplCopyWithImpl(
      _$TvKeyOkImpl _value, $Res Function(_$TvKeyOkImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyOkImpl extends TvKeyOk {
  const _$TvKeyOkImpl() : super._();

  @override
  String toString() {
    return 'TvKey.ok()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyOkImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return ok();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return ok?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (ok != null) {
      return ok();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return ok(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return ok?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (ok != null) {
      return ok(this);
    }
    return orElse();
  }
}

abstract class TvKeyOk extends TvKey {
  const factory TvKeyOk() = _$TvKeyOkImpl;
  const TvKeyOk._() : super._();
}

/// @nodoc
abstract class _$$TvKeyUnknownImplCopyWith<$Res> {
  factory _$$TvKeyUnknownImplCopyWith(
          _$TvKeyUnknownImpl value, $Res Function(_$TvKeyUnknownImpl) then) =
      __$$TvKeyUnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TvKeyUnknownImplCopyWithImpl<$Res>
    extends _$TvKeyCopyWithImpl<$Res, _$TvKeyUnknownImpl>
    implements _$$TvKeyUnknownImplCopyWith<$Res> {
  __$$TvKeyUnknownImplCopyWithImpl(
      _$TvKeyUnknownImpl _value, $Res Function(_$TvKeyUnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TvKeyUnknownImpl extends TvKeyUnknown {
  const _$TvKeyUnknownImpl() : super._();

  @override
  String toString() {
    return 'TvKey.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TvKeyUnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() up,
    required TResult Function() down,
    required TResult Function() left,
    required TResult Function() right,
    required TResult Function() ok,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? up,
    TResult? Function()? down,
    TResult? Function()? left,
    TResult? Function()? right,
    TResult? Function()? ok,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? up,
    TResult Function()? down,
    TResult Function()? left,
    TResult Function()? right,
    TResult Function()? ok,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TvKeyUp value) up,
    required TResult Function(TvKeyDown value) down,
    required TResult Function(TvKeyLeft value) left,
    required TResult Function(TvKeyRight value) right,
    required TResult Function(TvKeyOk value) ok,
    required TResult Function(TvKeyUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TvKeyUp value)? up,
    TResult? Function(TvKeyDown value)? down,
    TResult? Function(TvKeyLeft value)? left,
    TResult? Function(TvKeyRight value)? right,
    TResult? Function(TvKeyOk value)? ok,
    TResult? Function(TvKeyUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TvKeyUp value)? up,
    TResult Function(TvKeyDown value)? down,
    TResult Function(TvKeyLeft value)? left,
    TResult Function(TvKeyRight value)? right,
    TResult Function(TvKeyOk value)? ok,
    TResult Function(TvKeyUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class TvKeyUnknown extends TvKey {
  const factory TvKeyUnknown() = _$TvKeyUnknownImpl;
  const TvKeyUnknown._() : super._();
}
